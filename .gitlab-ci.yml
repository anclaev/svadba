default:
  image: node:18-alpine
  before_script:
    - corepack enable
    - yarn install

.docker:
  image: docker:28.0.1
  services:
    - docker:28.0.1-dind
  before_script:
    - echo "$CI_REGISTRY_TOKEN" | docker login -u $CI_REGISTRY_USER --password-stdin

.prepare-ssh:
  before_script:
    - "command -v ssh-agent >/dev/null || ( apk add --update openssh )"
    - eval $(ssh-agent -s)
    - chmod 400 "$SSH_PRIVATE_KEY"
    - ssh-add "$SSH_PRIVATE_KEY"
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -p 2219 $SSH_HOST >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts

variables:
  DOCKER_TLS_CERTDIR: "/certs"

stages:
  - install
  - tests
  - analyze
  - build
  - release
  - deploy

Install deps:
  stage: install
  script:
    - yarn
  cache:
    untracked: true
    paths:
      - node_modules/
      - .yarn

Unit tests:
  stage: tests
  needs:
    - Install deps
  script:
    - yarn turbo test:ci
  artifacts:
    when: always
    paths:
      - apps/bot/junit.xml
      - apps/web/junit.xml
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      allow_failure: true

E2E tests:
  stage: tests
  image: mcr.microsoft.com/playwright:v1.51.0-noble
  needs:
    - Install deps
  script:
    - CI=true yarn turbo e2e
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      allow_failure: true

Analyze code:
  stage: analyze
  image:
    name: sonarsource/sonar-scanner-cli:11
    entrypoint: [""]
  needs:
    - Unit tests
  before_script:
    - echo "Start analyze."
  script:
    - sonar-scanner -Dsonar.host.url="${SONAR_HOST_URL}"
  allow_failure: true
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"
    GIT_DEPTH: "0"

# Staging images

Build web (staging):
  extends: .docker
  stage: build
  needs:
    - Unit tests
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  script:
    - docker build -f apps/bot/Dockerfile -t $CI_IMAGE_TAG_WEB:$CI_COMMIT_SHORT_SHA .
    - docker push $CI_IMAGE_TAG_WEB:$CI_COMMIT_SHORT_SHA
  tags:
    - staging
  environment: staging

Build bot (staging):
  extends: .docker
  stage: build
  needs:
    - Unit tests
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  script:
    - docker build -f apps/bot/Dockerfile -t $CI_IMAGE_TAG_BOT:$CI_COMMIT_SHORT_SHA .
    - docker push $CI_IMAGE_TAG_BOT:$CI_COMMIT_SHORT_SHA
  tags:
    - staging
  environment: staging

# Production images

Build web:
  extends: .docker
  stage: build
  needs:
    - Unit tests
    - E2E tests
  rules:
    - if: $CI_COMMIT_TAG
  script:
    - docker build -f apps/web/Dockerfile -t $CI_IMAGE_TAG_WEB:$CI_COMMIT_TAG -t $CI_IMAGE_TAG_WEB:latest .
    - docker push $CI_IMAGE_TAG_WEB --all-tags
  tags:
    - production
  environment: production

Build bot:
  extends: .docker
  stage: build
  needs:
    - Unit tests
    - E2E tests
  rules:
    - if: $CI_COMMIT_TAG
  script:
    - docker build -f apps/bot/Dockerfile -t $CI_IMAGE_TAG_BOT:$CI_COMMIT_TAG -t $CI_IMAGE_TAG_BOT:latest .
    - docker push $CI_IMAGE_TAG_BOT --all-tags
  tags:
    - production
  environment: production

# Release

Release:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  needs:
    - Build bot
    - Build web
  rules:
    - if: $CI_COMMIT_TAG
  script:
    - echo "Running the release job."
  release:
    tag_name: $CI_COMMIT_TAG
    name: "Release $CI_COMMIT_TAG"
    description: "./CHANGELOG.md"

# Deploy

Deploy (staging):
  image: alpine:latest
  stage: deploy
  needs:
    - Build web (staging)
    - Build bot (staging)
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  extends: .prepare-ssh
  script:
    - ssh -p 2219 $SSH_USER@$SSH_HOST "cd $SSH_PATH && docker pull $CI_IMAGE_TAG_BOT:$CI_COMMIT_SHORT_SHA"
